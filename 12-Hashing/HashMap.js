var Node = function (key, value) {
  this.key = key;
  this.value = value;
  this.next = null;
};
var MyLinkedList = function () {
  this.head = null;
};

MyLinkedList.prototype.addAtHead = function (key, value) {
  let node = new Node(key, value);
  if (this.head == null) {
    this.head = node;
  } else {
    node.next = this.head;
    this.head = node;
  }
};
MyLinkedList.prototype.deleteAtHead = function () {
  if (this.head == null) return;
  let nextHead = this.head.next;
  let nodeToBeDelete = this.head; // curr head
  this.head = nextHead;
  nodeToBeDelete.next = null; // prev head disconnected
};

class HashMap {
  constructor() {
    this.lambdaFactorThreshold = 0.5; //threshold lambda factor
    this.lambdaFactorLowerThresold = 0.25;
    this.maxSize = 2;
    this.arr = Array(this.maxSize);
    for (let i = 0; i < this.maxSize; i++) {
      this.arr[i] = new MyLinkedList(); // Empty LL at each index
    }
    this.currSize = 0;
  }

  hashFunction(key) {
    //takes key as a parameter
    //apply the hashFunction on that key
    //the result of the hashFunction is the bucket indexin the given array
    let ans = 0; //this is going to final hashed value
    let p = 101; // prime number to key
    let pow = 1; // intially power is p^0
    let c = this.maxSize;
    for (let i = 0; i < key.length; i++) {
      //go to each charecter of given
      let asciiValue = this.ascii(key, i);
      ans = ((ans % c) + (((asciiValue % c) * (pow % c)) % c)) % c;

      //for next iteration we will increment the power
      pow = (((pow % c) * p) % c) % c;
    }
    return ans;
  }
  ascii(key, index) {
    //give us ascii
    return key.charCodeAt(index);
  }

  display() {
    for (let i = 0; i < this.arr.length; i++) {
      let temp = this.arr[i].head;
      let str = "LL: ";
      while (temp) {
        str += "(" + temp.key + "," + temp.value + ") -> ";
        temp = temp.next;
      }
      console.log(str);
    }
    console.log(this.currSize, this.maxSize);
  }
  update(key, value) {
    //key is always present
    const bucketIndex = this.hashFunction(key);
    let temp = this.arr[bucketIndex].head;
    while (temp) {
      if (temp.key == key) {
        temp.value = value;
        return;
      }
      temp = temp.next;
    }
  }
  insert(key, value) {
    if (this.search(key)) {
      // key value pair is already present

      // no need to insert just update
      this.update(key, value);
      return;
    }
    let newLoadFactor = (this.currSize + 1) / this.maxSize;
    if (newLoadFactor > this.lambdaFactorThreshold) {
      //if lambda increase to 0.5
      this.rehash();
    }
    const bucketIndex = this.hashFunction(key); //hashvalue generated by the function is bucket index
    this.arr[bucketIndex].addAtHead(key, value);
    this.currSize += 1; //Size of hash map increases
  }
  remove(key) {
    //Step 1-If key is present or not
    const value = this.search(key);
    if (!value) {
      console.log("Key is not present, nothing to to removed");
      return;
    }
    //Step 2-If key is present check in which LL bucket it is,using hasfunction

    const bucketIndex = this.hashFunction(key);
    let temp = this.arr[bucketIndex].head;

    //Step 3-Iterate on LL and remove the node
    if (temp.key == key) {
      //head node to be deleted
      this.arr[bucketIndex].deleteAtHead();
      this.currSize -= 1;
      const loadFactor = this.currSize / this.maxSize;
      if (loadFactor <= this.lambdaFactorLowerThresold) {
        this.rehash(0.5);
      }
      return;
    }

    while (temp) {
      //If the current node just behind the node to be deleted
      if (temp.next != null && temp.next.key == key) {
        const nodeToBeDelete = temp.next;
        temp.next = nodeToBeDelete.next; // attach prev node to next node
        nodeToBeDelete.next = null; // break the connection
        this.currSize -= 1;
        const loadFactor = this.currSize / this.maxSize;
        if (loadFactor <= this.lambdaFactorLowerThresold) {
          this.rehash(0.5);
        }
        return;
      }

      temp = temp.next;
    }
  }

  search(key) {
    //Impliment
    //Either key value pair present or not
    //If present then sure there is only one LL in which it will bw present
    //Calculate the bucket index

    const bucketIndex = this.hashFunction(key);

    let temp = this.arr[bucketIndex].head;
    while (temp) {
      if (temp.key == key) return temp.value;
      temp = temp.next;
    }
    return undefined;
  }

  rehash(factor = 2) {
    this.maxSize *= factor; //Double the capacity
    const newArr = Array(this.maxSize); //new array with updated capacity
    for (let i = 0; i < this.maxSize; i++) {
      newArr[i] = new MyLinkedList();
    }
    const oldArr = this.arr;

    //Iterate on each node of every LL and insert them in the newArr

    for (let i = 0; i < oldArr.length; i++) {
      //Each bucket has a LL
      let temp = oldArr[i].head;
      while (temp) {
        let key = temp.key;
        let value = temp.value;

        const bucketIndex = this.hashFunction(key);
        newArr[bucketIndex].addAtHead(key, value);
        temp = temp.next;
      }
    }

    this.arr = newArr;
  }
}

const hm = new HashMap();
hm.insert("mango", 10);
hm.insert("banana", 3);
hm.insert("apple", 4);
hm.insert("graps", 14);
hm.insert("potato", 16);
hm.display();
console.log("******");
console.log(hm.search("mango"));
console.log(hm.search("apple"));

hm.insert("mango", 55);
hm.display();
// hm.remove("mango");
// hm.remove("apple");
// hm.remove("graps");
// hm.remove("banana");
// hm.display();
